import enum
import io
from _typeshed import Incomplete
from sublime_types import CommandArgs as CommandArgs, CompletionValue as CompletionValue, DIP as DIP, Kind as Kind, Point as Point, Value as Value, Vector as Vector
from typing import Callable, Iterator, Literal, Optional

class _LogWriter(io.TextIOBase):
    buf: Incomplete
    def __init__(self) -> None: ...
    def flush(self) -> None: ...
    def write(self, s) -> None: ...

class HoverZone(enum.IntEnum):
    TEXT: int
    GUTTER: int
    MARGIN: int

HOVER_TEXT: Incomplete
HOVER_GUTTER: Incomplete
HOVER_MARGIN: Incomplete

class NewFileFlags(enum.IntFlag):
    NONE: int
    ENCODED_POSITION: int
    TRANSIENT: int
    FORCE_GROUP: int
    SEMI_TRANSIENT: int
    ADD_TO_SELECTION: int
    REPLACE_MRU: int
    CLEAR_TO_RIGHT: int
    FORCE_CLONE: int

ENCODED_POSITION: Incomplete
TRANSIENT: Incomplete
FORCE_GROUP: Incomplete
SEMI_TRANSIENT: Incomplete
ADD_TO_SELECTION: Incomplete
REPLACE_MRU: Incomplete
CLEAR_TO_RIGHT: Incomplete
FORCE_CLONE: Incomplete

class FindFlags(enum.IntFlag):
    NONE: int
    LITERAL: int
    IGNORECASE: int
    WHOLEWORD: int
    REVERSE: int
    WRAP: int

LITERAL: Incomplete
IGNORECASE: Incomplete
WHOLEWORD: Incomplete
REVERSE: Incomplete
WRAP: Incomplete

class QuickPanelFlags(enum.IntFlag):
    NONE: int
    MONOSPACE_FONT: int
    KEEP_OPEN_ON_FOCUS_LOST: int
    WANT_EVENT: int

MONOSPACE_FONT: Incomplete
KEEP_OPEN_ON_FOCUS_LOST: Incomplete
WANT_EVENT: Incomplete

class PopupFlags(enum.IntFlag):
    NONE: int
    COOPERATE_WITH_AUTO_COMPLETE: int
    HIDE_ON_MOUSE_MOVE: int
    HIDE_ON_MOUSE_MOVE_AWAY: int
    KEEP_ON_SELECTION_MODIFIED: int
    HIDE_ON_CHARACTER_EVENT: int

HTML: int
COOPERATE_WITH_AUTO_COMPLETE: Incomplete
HIDE_ON_MOUSE_MOVE: Incomplete
HIDE_ON_MOUSE_MOVE_AWAY: Incomplete
KEEP_ON_SELECTION_MODIFIED: Incomplete
HIDE_ON_CHARACTER_EVENT: Incomplete

class RegionFlags(enum.IntFlag):
    NONE: int
    DRAW_EMPTY: int
    HIDE_ON_MINIMAP: int
    DRAW_EMPTY_AS_OVERWRITE: int
    PERSISTENT: int
    DRAW_NO_FILL: int
    HIDDEN: int
    DRAW_NO_OUTLINE: int
    DRAW_SOLID_UNDERLINE: int
    DRAW_STIPPLED_UNDERLINE: int
    DRAW_SQUIGGLY_UNDERLINE: int
    NO_UNDO: int

DRAW_EMPTY: Incomplete
HIDE_ON_MINIMAP: Incomplete
DRAW_EMPTY_AS_OVERWRITE: Incomplete
PERSISTENT: Incomplete
DRAW_NO_FILL: Incomplete
DRAW_OUTLINED = DRAW_NO_FILL
DRAW_NO_OUTLINE: Incomplete
DRAW_SOLID_UNDERLINE: Incomplete
DRAW_STIPPLED_UNDERLINE: Incomplete
DRAW_SQUIGGLY_UNDERLINE: Incomplete
NO_UNDO: Incomplete
HIDDEN: Incomplete

class QueryOperator(enum.IntEnum):
    EQUAL: int
    NOT_EQUAL: int
    REGEX_MATCH: int
    NOT_REGEX_MATCH: int
    REGEX_CONTAINS: int
    NOT_REGEX_CONTAINS: int

OP_EQUAL: Incomplete
OP_NOT_EQUAL: Incomplete
OP_REGEX_MATCH: Incomplete
OP_NOT_REGEX_MATCH: Incomplete
OP_REGEX_CONTAINS: Incomplete
OP_NOT_REGEX_CONTAINS: Incomplete

class PointClassification(enum.IntFlag):
    NONE: int
    WORD_START: int
    WORD_END: int
    PUNCTUATION_START: int
    PUNCTUATION_END: int
    SUB_WORD_START: int
    SUB_WORD_END: int
    LINE_START: int
    LINE_END: int
    EMPTY_LINE: int

CLASS_WORD_START: Incomplete
CLASS_WORD_END: Incomplete
CLASS_PUNCTUATION_START: Incomplete
CLASS_PUNCTUATION_END: Incomplete
CLASS_SUB_WORD_START: Incomplete
CLASS_SUB_WORD_END: Incomplete
CLASS_LINE_START: Incomplete
CLASS_LINE_END: Incomplete
CLASS_EMPTY_LINE: Incomplete

class AutoCompleteFlags(enum.IntFlag):
    NONE: int
    INHIBIT_WORD_COMPLETIONS: int
    INHIBIT_EXPLICIT_COMPLETIONS: int
    DYNAMIC_COMPLETIONS: int
    INHIBIT_REORDER: int

INHIBIT_WORD_COMPLETIONS: Incomplete
INHIBIT_EXPLICIT_COMPLETIONS: Incomplete
DYNAMIC_COMPLETIONS: Incomplete
INHIBIT_REORDER: Incomplete

class CompletionItemFlags(enum.IntFlag):
    NONE: int
    KEEP_PREFIX: int

COMPLETION_FLAG_KEEP_PREFIX: Incomplete

class DialogResult(enum.IntEnum):
    CANCEL: int
    YES: int
    NO: int

DIALOG_CANCEL: Incomplete
DIALOG_YES: Incomplete
DIALOG_NO: Incomplete

class UIElement(enum.IntEnum):
    SIDE_BAR: int
    MINIMAP: int
    TABS: int
    STATUS_BAR: int
    MENU: int
    OPEN_FILES: int

class PhantomLayout(enum.IntEnum):
    INLINE: int
    BELOW: int
    BLOCK: int

LAYOUT_INLINE: Incomplete
LAYOUT_BELOW: Incomplete
LAYOUT_BLOCK: Incomplete

class KindId(enum.IntEnum):
    AMBIGUOUS: int
    KEYWORD: int
    TYPE: int
    FUNCTION: int
    NAMESPACE: int
    NAVIGATION: int
    MARKUP: int
    VARIABLE: int
    SNIPPET: int
    COLOR_REDISH: int
    COLOR_ORANGISH: int
    COLOR_YELLOWISH: int
    COLOR_GREENISH: int
    COLOR_CYANISH: int
    COLOR_BLUISH: int
    COLOR_PURPLISH: int
    COLOR_PINKISH: int
    COLOR_DARK: int
    COLOR_LIGHT: int

KIND_ID_AMBIGUOUS: Incomplete
KIND_ID_KEYWORD: Incomplete
KIND_ID_TYPE: Incomplete
KIND_ID_FUNCTION: Incomplete
KIND_ID_NAMESPACE: Incomplete
KIND_ID_NAVIGATION: Incomplete
KIND_ID_MARKUP: Incomplete
KIND_ID_VARIABLE: Incomplete
KIND_ID_SNIPPET: Incomplete
KIND_ID_COLOR_REDISH: Incomplete
KIND_ID_COLOR_ORANGISH: Incomplete
KIND_ID_COLOR_YELLOWISH: Incomplete
KIND_ID_COLOR_GREENISH: Incomplete
KIND_ID_COLOR_CYANISH: Incomplete
KIND_ID_COLOR_BLUISH: Incomplete
KIND_ID_COLOR_PURPLISH: Incomplete
KIND_ID_COLOR_PINKISH: Incomplete
KIND_ID_COLOR_DARK: Incomplete
KIND_ID_COLOR_LIGHT: Incomplete
KIND_AMBIGUOUS: Incomplete
KIND_KEYWORD: Incomplete
KIND_TYPE: Incomplete
KIND_FUNCTION: Incomplete
KIND_NAMESPACE: Incomplete
KIND_NAVIGATION: Incomplete
KIND_MARKUP: Incomplete
KIND_VARIABLE: Incomplete
KIND_SNIPPET: Incomplete

class SymbolSource(enum.IntEnum):
    ANY: int
    INDEX: int
    OPEN_FILES: int

SYMBOL_SOURCE_ANY: Incomplete
SYMBOL_SOURCE_INDEX: Incomplete
SYMBOL_SOURCE_OPEN_FILES: Incomplete

class SymbolType(enum.IntEnum):
    ANY: int
    DEFINITION: int
    REFERENCE: int

SYMBOL_TYPE_ANY: Incomplete
SYMBOL_TYPE_DEFINITION: Incomplete
SYMBOL_TYPE_REFERENCE: Incomplete

class CompletionFormat(enum.IntEnum):
    TEXT: int
    SNIPPET: int
    COMMAND: int

COMPLETION_FORMAT_TEXT: Incomplete
COMPLETION_FORMAT_SNIPPET: Incomplete
COMPLETION_FORMAT_COMMAND: Incomplete

def version() -> str: ...
def platform() -> Literal['osx', 'linux', 'windows']: ...
def arch() -> Literal['x32', 'x64', 'arm64']: ...
def channel() -> Literal['dev', 'stable']: ...
def executable_path() -> str: ...
def executable_hash() -> tuple[str, str, str]: ...
def packages_path() -> str: ...
def installed_packages_path() -> str: ...
def cache_path() -> str: ...
def status_message(msg: str): ...
def error_message(msg: str): ...
def message_dialog(msg: str): ...
def ok_cancel_dialog(msg: str, ok_title: str = ..., title: str = ...) -> bool: ...
def yes_no_cancel_dialog(msg: str, yes_title: str = ..., no_title: str = ..., title: str = ...) -> DialogResult: ...
def open_dialog(callback: Callable[[str | list[str] | None], None], file_types: list[tuple[str, list[str]]] = ..., directory: Optional[str] = ..., multi_select: bool = ..., allow_folders: bool = ...): ...
def save_dialog(callback: Callable[[str | None], None], file_types: list[tuple[str, list[str]]] = ..., directory: Optional[str] = ..., name: Optional[str] = ..., extension: Optional[str] = ...): ...
def select_folder_dialog(callback: Callable[[str | list[str] | None], None], directory: Optional[str] = ..., multi_select: bool = ...): ...
def run_command(cmd: str, args: CommandArgs = ...): ...
def format_command(cmd: str, args: CommandArgs = ...) -> str: ...
def html_format_command(cmd: str, args: CommandArgs = ...) -> str: ...
def command_url(cmd: str, args: CommandArgs = ...) -> str: ...
def get_clipboard_async(callback: Callable[[str], None], size_limit: int = ...): ...
def get_clipboard(size_limit: int = ...) -> str: ...
def set_clipboard(text: str): ...
def log_commands(flag: Optional[bool] = ...): ...
def get_log_commands() -> bool: ...
def log_input(flag: Optional[bool] = ...): ...
def get_log_input() -> bool: ...
def log_fps(flag: Optional[bool] = ...): ...
def get_log_fps() -> bool: ...
def log_result_regex(flag: Optional[bool] = ...): ...
def get_log_result_regex() -> bool: ...
def log_indexing(flag: Optional[bool] = ...): ...
def get_log_indexing() -> bool: ...
def log_build_systems(flag: Optional[bool] = ...): ...
def get_log_build_systems() -> bool: ...
def log_control_tree(flag: Optional[bool] = ...): ...
def get_log_control_tree() -> bool: ...
def ui_info() -> dict: ...
def score_selector(scope_name: str, selector: str) -> int: ...
def load_resource(name: str) -> str: ...
def load_binary_resource(name) -> bytes: ...
def find_resources(pattern: str) -> list[str]: ...
def encode_value(value: Value, pretty: bool = ...) -> str: ...
def decode_value(data: str) -> Value: ...
def expand_variables(value: Value, variables: dict[str, str]) -> Value: ...
def load_settings(base_name: str) -> Settings: ...
def save_settings(base_name: str): ...
def set_timeout(callback: Callable, delay: int = ...): ...
def set_timeout_async(callback: Callable, delay: int = ...): ...
def active_window() -> Window: ...
def windows() -> list[Window]: ...
def get_macro() -> list[dict]: ...
def project_history() -> list[str]: ...
def folder_history() -> list[str]: ...

class Window:
    window_id: Incomplete
    settings_object: Incomplete
    template_settings_object: Incomplete
    def __init__(self, id: int) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other): ...
    def __bool__(self) -> bool: ...
    def id(self) -> int: ...
    def is_valid(self) -> bool: ...
    def hwnd(self) -> int: ...
    def active_sheet(self) -> Optional[Sheet]: ...
    def active_view(self) -> Optional[View]: ...
    def new_html_sheet(self, name: str, contents: str, flags=..., group: int = ...) -> Sheet: ...
    def run_command(self, cmd: str, args: CommandArgs = ...): ...
    def new_file(self, flags=..., syntax: str = ...) -> View: ...
    def open_file(self, fname: str, flags=..., group: int = ...) -> View: ...
    def find_open_file(self, fname: str, group: int = ...) -> Optional[View]: ...
    def file_history(self) -> list[str]: ...
    def num_groups(self) -> int: ...
    def active_group(self) -> int: ...
    def focus_group(self, idx: int): ...
    def focus_sheet(self, sheet: Sheet): ...
    def focus_view(self, view: View): ...
    def select_sheets(self, sheets: list[Sheet]): ...
    def bring_to_front(self) -> None: ...
    def get_sheet_index(self, sheet: Sheet) -> tuple[int, int]: ...
    def get_view_index(self, view: View) -> tuple[int, int]: ...
    def set_sheet_index(self, sheet: Sheet, group: int, index: int): ...
    def set_view_index(self, view: View, group: int, index: int): ...
    def move_sheets_to_group(self, sheets: list[Sheet], group: int, insertion_idx: int = ..., select: bool = ...): ...
    def sheets(self) -> list[Sheet]: ...
    def views(self, *, include_transient: bool = ...) -> list[View]: ...
    def selected_sheets(self) -> list[Sheet]: ...
    def selected_sheets_in_group(self, group: int) -> list[Sheet]: ...
    def active_sheet_in_group(self, group: int) -> Optional[Sheet]: ...
    def active_view_in_group(self, group: int) -> Optional[View]: ...
    def sheets_in_group(self, group: int) -> list[Sheet]: ...
    def views_in_group(self, group: int) -> list[View]: ...
    def num_sheets_in_group(self, group: int) -> int: ...
    def num_views_in_group(self, group: int) -> int: ...
    def transient_sheet_in_group(self, group: int) -> Optional[Sheet]: ...
    def transient_view_in_group(self, group: int) -> Optional[View]: ...
    def promote_sheet(self, sheet: Sheet): ...
    def layout(self) -> dict[str, Value]: ...
    def get_layout(self): ...
    def set_layout(self, layout: dict[str, Value]): ...
    def create_output_panel(self, name: str, unlisted: bool = ...) -> View: ...
    def find_output_panel(self, name: str) -> Optional[View]: ...
    def destroy_output_panel(self, name: str): ...
    def active_panel(self) -> Optional[str]: ...
    def panels(self) -> list[str]: ...
    def get_output_panel(self, name: str): ...
    def show_input_panel(self, caption: str, initial_text: str, on_done: Optional[Callable[[str], None]], on_change: Optional[Callable[[str], None]], on_cancel: Optional[Callable[[], None]]): ...
    def show_quick_panel(self, items: list[str] | list[list[str]] | list[QuickPanelItem], on_select: Callable[[int], None], flags=..., selected_index: int = ..., on_highlight: Optional[Callable[[int], None]] = ..., placeholder: Optional[str] = ...): ...
    def is_sidebar_visible(self) -> bool: ...
    def set_sidebar_visible(self, flag: bool, animate: bool = ...): ...
    def is_minimap_visible(self) -> bool: ...
    def set_minimap_visible(self, flag: bool): ...
    def is_status_bar_visible(self) -> bool: ...
    def set_status_bar_visible(self, flag: bool): ...
    def get_tabs_visible(self) -> bool: ...
    def set_tabs_visible(self, flag: bool): ...
    def is_menu_visible(self) -> bool: ...
    def set_menu_visible(self, flag: bool): ...
    def folders(self) -> list[str]: ...
    def project_file_name(self) -> Optional[str]: ...
    def workspace_file_name(self) -> Optional[str]: ...
    def project_data(self) -> Value: ...
    def set_project_data(self, data: Value): ...
    def settings(self) -> Settings: ...
    def template_settings(self) -> Settings: ...
    def symbol_locations(self, sym: str, source=..., type=..., kind_id=..., kind_letter: str = ...) -> list[SymbolLocation]: ...
    def lookup_symbol_in_index(self, symbol: str) -> list[SymbolLocation]: ...
    def lookup_symbol_in_open_files(self, symbol: str) -> list[SymbolLocation]: ...
    def lookup_references_in_index(self, symbol: str) -> list[SymbolLocation]: ...
    def lookup_references_in_open_files(self, symbol: str) -> list[SymbolLocation]: ...
    def extract_variables(self) -> dict[str, str]: ...
    def status_message(self, msg: str): ...

class Edit:
    edit_token: Incomplete
    def __init__(self, token) -> None: ...

class Region:
    a: Incomplete
    b: Incomplete
    xpos: Incomplete
    def __init__(self, a: Point, b: Optional[Point] = ..., xpos: DIP = ...) -> None: ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def __eq__(self, rhs: object) -> bool: ...
    def __lt__(self, rhs: Region) -> bool: ...
    def __contains__(self, v: Region | Point) -> bool: ...
    def to_tuple(self) -> tuple[Point, Point]: ...
    def empty(self) -> bool: ...
    def begin(self) -> Point: ...
    def end(self) -> Point: ...
    def size(self) -> int: ...
    def contains(self, x: Point) -> bool: ...
    def cover(self, region: Region) -> Region: ...
    def intersection(self, region: Region) -> Region: ...
    def intersects(self, region: Region) -> bool: ...

class HistoricPosition:
    pt: Incomplete
    row: Incomplete
    col: Incomplete
    col_utf16: Incomplete
    col_utf8: Incomplete
    def __init__(self, pt, row, col, col_utf16, col_utf8) -> None: ...

class TextChange:
    a: Incomplete
    b: Incomplete
    len_utf16: Incomplete
    len_utf8: Incomplete
    str: Incomplete
    def __init__(self, pa, pb, len_utf16, len_utf8, str) -> None: ...

class Selection:
    view_id: Incomplete
    def __init__(self, id) -> None: ...
    def __iter__(self) -> Iterator[Region]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> Region: ...
    def __delitem__(self, index: int): ...
    def __eq__(self, rhs: object) -> bool: ...
    def __lt__(self, rhs: Optional[Selection]) -> bool: ...
    def __bool__(self) -> bool: ...
    def is_valid(self) -> bool: ...
    def clear(self) -> None: ...
    def add(self, x: Region | Point): ...
    def add_all(self, regions: Iterator[Region]): ...
    def subtract(self, region: Region): ...
    def contains(self, region: Region) -> bool: ...

def make_sheet(sheet_id): ...

class Sheet:
    sheet_id: Incomplete
    def __init__(self, id) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def id(self) -> int: ...
    def window(self) -> Optional[Window]: ...
    def view(self) -> Optional[View]: ...
    def file_name(self) -> Optional[str]: ...
    def is_semi_transient(self) -> bool: ...
    def is_transient(self) -> bool: ...
    def is_selected(self) -> bool: ...
    def group(self) -> Optional[int]: ...
    def close(self, on_close=...) -> None: ...

class TextSheet(Sheet):
    def set_name(self, name: str): ...

class ImageSheet(Sheet): ...

class HtmlSheet(Sheet):
    def set_name(self, name: str): ...
    def set_contents(self, contents: str): ...

class ContextStackFrame:
    context_name: Incomplete
    source_file: Incomplete
    source_location: Incomplete
    def __init__(self, context_name, source_file, source_location) -> None: ...

class View:
    view_id: Incomplete
    selection: Incomplete
    settings_object: Incomplete
    def __init__(self, id) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __bool__(self) -> bool: ...
    def id(self) -> int: ...
    def buffer_id(self) -> int: ...
    def buffer(self) -> Buffer: ...
    def sheet_id(self) -> int: ...
    def sheet(self) -> Optional[Sheet]: ...
    def element(self) -> Optional[str]: ...
    def is_valid(self) -> bool: ...
    def is_primary(self) -> bool: ...
    def window(self) -> Optional[Window]: ...
    def clones(self) -> list[View]: ...
    def file_name(self) -> Optional[str]: ...
    def close(self, on_close=...) -> bool: ...
    def retarget(self, new_fname: str): ...
    def name(self) -> str: ...
    def set_name(self, name: str): ...
    def reset_reference_document(self) -> None: ...
    def set_reference_document(self, reference: str): ...
    def is_loading(self) -> bool: ...
    def is_dirty(self) -> bool: ...
    def is_read_only(self) -> bool: ...
    def set_read_only(self, read_only: bool): ...
    def is_scratch(self) -> bool: ...
    def set_scratch(self, scratch: bool): ...
    def encoding(self) -> str: ...
    def set_encoding(self, encoding_name: str): ...
    def line_endings(self) -> str: ...
    def set_line_endings(self, line_ending_name: str): ...
    def size(self) -> int: ...
    def begin_edit(self, edit_token: int, cmd: str, args: CommandArgs = ...) -> Edit: ...
    def end_edit(self, edit: Edit): ...
    def is_in_edit(self) -> bool: ...
    def insert(self, edit: Edit, pt: Point, text: str) -> int: ...
    def erase(self, edit: Edit, region: Region): ...
    def replace(self, edit: Edit, region: Region, text: str): ...
    def change_count(self) -> int: ...
    def change_id(self) -> tuple[int, int, int]: ...
    def transform_region_from(self, region: Region, change_id: tuple[int, int, int]) -> Region: ...
    def run_command(self, cmd: str, args: CommandArgs = ...): ...
    def sel(self) -> Selection: ...
    def substr(self, x: Region | Point) -> str: ...
    def find(self, pattern: str, start_pt: Point, flags=...) -> Region: ...
    def find_all(self, pattern: str, flags=..., fmt: Optional[str] = ..., extractions: Optional[list[str]] = ...) -> list[Region]: ...
    def settings(self) -> Settings: ...
    def meta_info(self, key: str, pt: Point) -> Value: ...
    def extract_tokens_with_scopes(self, region: Region) -> list[tuple[Region, str]]: ...
    def extract_scope(self, pt: Point) -> Region: ...
    def expand_to_scope(self, pt: Point, selector: str) -> Optional[Region]: ...
    def scope_name(self, pt: Point) -> str: ...
    def context_backtrace(self, pt: Point) -> list[ContextStackFrame]: ...
    def match_selector(self, pt: Point, selector: str) -> bool: ...
    def score_selector(self, pt: Point, selector: str) -> int: ...
    def find_by_selector(self, selector: str) -> list[Region]: ...
    def style(self) -> dict[str, str]: ...
    def style_for_scope(self, scope: str) -> dict[str, str]: ...
    def indented_region(self, pt: Point) -> Region: ...
    def indentation_level(self, pt: Point) -> int: ...
    def has_non_empty_selection_region(self) -> bool: ...
    def lines(self, region: Region) -> list[Region]: ...
    def split_by_newlines(self, region: Region) -> list[Region]: ...
    def line(self, x: Region | Point) -> Region: ...
    def full_line(self, x: Region | Point) -> Region: ...
    def word(self, x: Region | Point) -> Region: ...
    def classify(self, pt: Point) -> PointClassification: ...
    def find_by_class(self, pt: Point, forward: bool, classes: PointClassification, separators: str = ..., sub_word_separators: str = ...) -> Point: ...
    def expand_by_class(self, x: Region | Point, classes: PointClassification, separators: str = ..., sub_word_separators: str = ...) -> Region: ...
    def rowcol(self, tp: Point) -> tuple[int, int]: ...
    def rowcol_utf8(self, tp: Point) -> tuple[int, int]: ...
    def rowcol_utf16(self, tp: Point) -> tuple[int, int]: ...
    def text_point(self, row: int, col: int, *, clamp_column: bool = ...) -> Point: ...
    def text_point_utf8(self, row: int, col: int, *, clamp_column: bool = ...) -> Point: ...
    def text_point_utf16(self, row: int, col: int, *, clamp_column: bool = ...) -> Point: ...
    def visible_region(self) -> Region: ...
    def show(self, location: Region | Selection | Point, show_surrounds: bool = ..., keep_to_left: bool = ..., animate: bool = ...): ...
    def show_at_center(self, location: Region | Point, animate: bool = ...): ...
    def viewport_position(self) -> Vector: ...
    def set_viewport_position(self, xy: Vector, animate: bool = ...): ...
    def viewport_extent(self) -> Vector: ...
    def layout_extent(self) -> Vector: ...
    def text_to_layout(self, tp: Point) -> Vector: ...
    def text_to_window(self, tp: Point) -> Vector: ...
    def layout_to_text(self, xy: Vector) -> Point: ...
    def layout_to_window(self, xy: Vector) -> Vector: ...
    def window_to_layout(self, xy: Vector) -> Vector: ...
    def window_to_text(self, xy: Vector) -> Point: ...
    def line_height(self) -> DIP: ...
    def em_width(self) -> DIP: ...
    def is_folded(self, region: Region) -> bool: ...
    def folded_regions(self) -> list[Region]: ...
    def fold(self, x: Region | list[Region]) -> bool: ...
    def unfold(self, x: Region | list[Region]) -> list[Region]: ...
    def add_regions(self, key: str, regions: list[Region], scope: str = ..., icon: str = ..., flags=..., annotations: list[str] = ..., annotation_color: str = ..., on_navigate: Optional[Callable[[str], None]] = ..., on_close: Optional[Callable[[], None]] = ...): ...
    def get_regions(self, key: str) -> list[Region]: ...
    def erase_regions(self, key: str): ...
    def add_phantom(self, key: str, region: Region, content: str, layout: PhantomLayout, on_navigate: Optional[Callable[[str], None]] = ...) -> int: ...
    def erase_phantoms(self, key: str): ...
    def erase_phantom_by_id(self, pid: int): ...
    def query_phantom(self, pid: int) -> list[Region]: ...
    def query_phantoms(self, pids: list[int]) -> list[Region]: ...
    def assign_syntax(self, syntax: str | Syntax): ...
    def set_syntax_file(self, syntax_file: str): ...
    def syntax(self) -> Optional[Syntax]: ...
    def symbols(self) -> list[tuple[Region, str]]: ...
    def get_symbols(self) -> list[tuple[Region, str]]: ...
    def indexed_symbols(self) -> list[tuple[Region, str]]: ...
    def indexed_references(self) -> list[tuple[Region, str]]: ...
    def symbol_regions(self) -> list[SymbolRegion]: ...
    def indexed_symbol_regions(self, type=...) -> list[SymbolRegion]: ...
    def set_status(self, key: str, value: str): ...
    def get_status(self, key: str) -> str: ...
    def erase_status(self, key: str): ...
    def extract_completions(self, prefix: str, tp: Point = ...) -> list[str]: ...
    def find_all_results(self) -> list[tuple[str, int, int]]: ...
    def find_all_results_with_text(self) -> list[tuple[str, int, int, str]]: ...
    def command_history(self, index: int, modifying_only: bool = ...) -> tuple[str, CommandArgs, int]: ...
    def overwrite_status(self) -> bool: ...
    def set_overwrite_status(self, value: bool): ...
    def show_popup_menu(self, items: list[str], on_done: Callable[[int], None], flags: int = ...): ...
    def show_popup(self, content: str, flags=..., location: Point = ..., max_width: DIP = ..., max_height: DIP = ..., on_navigate: Optional[Callable[[str], None]] = ..., on_hide: Optional[Callable[[], None]] = ...): ...
    def update_popup(self, content: str): ...
    def is_popup_visible(self) -> bool: ...
    def hide_popup(self) -> None: ...
    def is_auto_complete_visible(self) -> bool: ...
    def preserve_auto_complete_on_focus_lost(self) -> None: ...
    def export_to_html(self, regions: Optional[Region | list[Region]] = ..., minihtml: bool = ..., enclosing_tags: bool = ..., font_size: bool = ..., font_family: bool = ...): ...
    def clear_undo_stack(self) -> None: ...

class Buffer:
    buffer_id: Incomplete
    def __init__(self, id) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def id(self) -> int: ...
    def file_name(self) -> Optional[str]: ...
    def views(self) -> list[View]: ...
    def primary_view(self) -> View: ...

class Settings:
    settings_id: Incomplete
    def __init__(self, id) -> None: ...
    def __getitem__(self, key: str) -> Value: ...
    def __setitem__(self, key: str, value: Value): ...
    def __delitem__(self, key: str): ...
    def __contains__(self, key: str) -> bool: ...
    def to_dict(self) -> dict: ...
    def setdefault(self, key: str, value: Value): ...
    def update(self, other=..., **kwargs) -> None: ...
    def get(self, key: str, default: Value = ...) -> Value: ...
    def has(self, key: str) -> bool: ...
    def set(self, key: str, value: Value): ...
    def erase(self, key: str): ...
    def add_on_change(self, tag: str, callback: Callable[[], None]): ...
    def clear_on_change(self, tag: str): ...

class Phantom:
    region: Incomplete
    content: Incomplete
    layout: Incomplete
    on_navigate: Incomplete
    id: Incomplete
    def __init__(self, region, content, layout, on_navigate: Incomplete | None = ...) -> None: ...
    def __eq__(self, rhs: object) -> bool: ...
    def to_tuple(self) -> tuple[tuple[Point, Point], str, PhantomLayout, Optional[Callable[[str], None]]]: ...

class PhantomSet:
    view: Incomplete
    key: Incomplete
    phantoms: Incomplete
    def __init__(self, view, key: str = ...) -> None: ...
    def __del__(self) -> None: ...
    def update(self, phantoms: Iterator[Phantom]): ...

class Html:
    data: Incomplete
    def __init__(self, data) -> None: ...

class CompletionList:
    target: Incomplete
    completions: Incomplete
    flags: Incomplete
    def __init__(self, completions: Optional[list[CompletionValue]] = ..., flags=...) -> None: ...
    def set_completions(self, completions: list[CompletionValue], flags=...): ...

class CompletionItem:
    trigger: Incomplete
    annotation: Incomplete
    completion: Incomplete
    completion_format: Incomplete
    kind: Incomplete
    details: Incomplete
    flags: Incomplete
    def __init__(self, trigger, annotation: str = ..., completion: str = ..., completion_format=..., kind=..., details: str = ..., flags=...) -> None: ...
    def __eq__(self, rhs: object) -> bool: ...
    @classmethod
    def snippet_completion(cls, trigger: str, snippet: str, annotation: str = ..., kind=..., details: str = ...) -> CompletionItem: ...
    @classmethod
    def command_completion(cls, trigger: str, command: str, args: CommandArgs = ..., annotation: str = ..., kind=..., details: str = ...) -> CompletionItem: ...

def list_syntaxes() -> list[Syntax]: ...
def syntax_from_path(path: str) -> Optional[Syntax]: ...
def find_syntax_by_name(name: str) -> list[Syntax]: ...
def find_syntax_by_scope(scope: str) -> list[Syntax]: ...
def find_syntax_for_file(path, first_line: str = ...) -> Optional[Syntax]: ...

class Syntax:
    path: Incomplete
    name: Incomplete
    hidden: Incomplete
    scope: Incomplete
    def __init__(self, path, name, hidden, scope) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

class QuickPanelItem:
    trigger: Incomplete
    details: Incomplete
    annotation: Incomplete
    kind: Incomplete
    def __init__(self, trigger, details: str = ..., annotation: str = ..., kind=...) -> None: ...

class ListInputItem:
    text: Incomplete
    value: Incomplete
    details: Incomplete
    annotation: Incomplete
    kind: Incomplete
    def __init__(self, text, value, details: str = ..., annotation: str = ..., kind=...) -> None: ...

class SymbolRegion:
    name: Incomplete
    region: Incomplete
    syntax: Incomplete
    type: Incomplete
    kind: Incomplete
    def __init__(self, name, region, syntax, type, kind) -> None: ...

class SymbolLocation:
    path: Incomplete
    display_name: Incomplete
    row: Incomplete
    col: Incomplete
    syntax: Incomplete
    type: Incomplete
    kind: Incomplete
    def __init__(self, path, display_name, row, col, syntax, type, kind) -> None: ...
    def path_encoded_position(self) -> str: ...
