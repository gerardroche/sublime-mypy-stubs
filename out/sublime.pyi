import enum
import io
from sublime_types import CommandArgs as CommandArgs, CompletionValue as CompletionValue, DIP as DIP, Kind as Kind, Point as Point, Value as Value, Vector as Vector
from typing import Any, Callable, Iterable, Iterator, Literal, Optional

class _LogWriter(io.TextIOBase):
    buf: Any
    def __init__(self) -> None: ...
    def flush(self) -> None: ...
    def write(self, s) -> None: ...

class HoverZone(enum.IntEnum):
    TEXT: int
    GUTTER: int
    MARGIN: int

HOVER_TEXT: Any
HOVER_GUTTER: Any
HOVER_MARGIN: Any

class NewFileFlags(enum.IntFlag):
    NONE: int
    ENCODED_POSITION: int
    TRANSIENT: int
    FORCE_GROUP: int
    SEMI_TRANSIENT: int
    ADD_TO_SELECTION: int
    REPLACE_MRU: int
    CLEAR_TO_RIGHT: int
    FORCE_CLONE: int

ENCODED_POSITION: Any
TRANSIENT: Any
FORCE_GROUP: Any
SEMI_TRANSIENT: Any
ADD_TO_SELECTION: Any
REPLACE_MRU: Any
CLEAR_TO_RIGHT: Any
FORCE_CLONE: Any

class FindFlags(enum.IntFlag):
    NONE: int
    LITERAL: int
    IGNORECASE: int
    WHOLEWORD: int
    REVERSE: int
    WRAP: int

LITERAL: Any
IGNORECASE: Any
WHOLEWORD: Any
REVERSE: Any
WRAP: Any

class QuickPanelFlags(enum.IntFlag):
    NONE: int
    MONOSPACE_FONT: int
    KEEP_OPEN_ON_FOCUS_LOST: int
    WANT_EVENT: int

MONOSPACE_FONT: Any
KEEP_OPEN_ON_FOCUS_LOST: Any
WANT_EVENT: Any

class PopupFlags(enum.IntFlag):
    NONE: int
    COOPERATE_WITH_AUTO_COMPLETE: int
    HIDE_ON_MOUSE_MOVE: int
    HIDE_ON_MOUSE_MOVE_AWAY: int
    KEEP_ON_SELECTION_MODIFIED: int
    HIDE_ON_CHARACTER_EVENT: int

HTML: int
COOPERATE_WITH_AUTO_COMPLETE: Any
HIDE_ON_MOUSE_MOVE: Any
HIDE_ON_MOUSE_MOVE_AWAY: Any
KEEP_ON_SELECTION_MODIFIED: Any
HIDE_ON_CHARACTER_EVENT: Any

class RegionFlags(enum.IntFlag):
    NONE: int
    DRAW_EMPTY: int
    HIDE_ON_MINIMAP: int
    DRAW_EMPTY_AS_OVERWRITE: int
    PERSISTENT: int
    DRAW_NO_FILL: int
    HIDDEN: int
    DRAW_NO_OUTLINE: int
    DRAW_SOLID_UNDERLINE: int
    DRAW_STIPPLED_UNDERLINE: int
    DRAW_SQUIGGLY_UNDERLINE: int
    NO_UNDO: int

DRAW_EMPTY: Any
HIDE_ON_MINIMAP: Any
DRAW_EMPTY_AS_OVERWRITE: Any
PERSISTENT: Any
DRAW_NO_FILL: Any
DRAW_OUTLINED = DRAW_NO_FILL
DRAW_NO_OUTLINE: Any
DRAW_SOLID_UNDERLINE: Any
DRAW_STIPPLED_UNDERLINE: Any
DRAW_SQUIGGLY_UNDERLINE: Any
NO_UNDO: Any
HIDDEN: Any

class QueryOperator(enum.IntEnum):
    EQUAL: int
    NOT_EQUAL: int
    REGEX_MATCH: int
    NOT_REGEX_MATCH: int
    REGEX_CONTAINS: int
    NOT_REGEX_CONTAINS: int

OP_EQUAL: Any
OP_NOT_EQUAL: Any
OP_REGEX_MATCH: Any
OP_NOT_REGEX_MATCH: Any
OP_REGEX_CONTAINS: Any
OP_NOT_REGEX_CONTAINS: Any

class PointClassification(enum.IntFlag):
    NONE: int
    WORD_START: int
    WORD_END: int
    PUNCTUATION_START: int
    PUNCTUATION_END: int
    SUB_WORD_START: int
    SUB_WORD_END: int
    LINE_START: int
    LINE_END: int
    EMPTY_LINE: int

CLASS_WORD_START: Any
CLASS_WORD_END: Any
CLASS_PUNCTUATION_START: Any
CLASS_PUNCTUATION_END: Any
CLASS_SUB_WORD_START: Any
CLASS_SUB_WORD_END: Any
CLASS_LINE_START: Any
CLASS_LINE_END: Any
CLASS_EMPTY_LINE: Any

class AutoCompleteFlags(enum.IntFlag):
    NONE: int
    INHIBIT_WORD_COMPLETIONS: int
    INHIBIT_EXPLICIT_COMPLETIONS: int
    DYNAMIC_COMPLETIONS: int
    INHIBIT_REORDER: int

INHIBIT_WORD_COMPLETIONS: Any
INHIBIT_EXPLICIT_COMPLETIONS: Any
DYNAMIC_COMPLETIONS: Any
INHIBIT_REORDER: Any

class CompletionItemFlags(enum.IntFlag):
    NONE: int
    KEEP_PREFIX: int

COMPLETION_FLAG_KEEP_PREFIX: Any

class DialogResult(enum.IntEnum):
    CANCEL: int
    YES: int
    NO: int

DIALOG_CANCEL: Any
DIALOG_YES: Any
DIALOG_NO: Any

class UIElement(enum.IntEnum):
    SIDE_BAR: int
    MINIMAP: int
    TABS: int
    STATUS_BAR: int
    MENU: int
    OPEN_FILES: int

class PhantomLayout(enum.IntEnum):
    INLINE: int
    BELOW: int
    BLOCK: int

LAYOUT_INLINE: Any
LAYOUT_BELOW: Any
LAYOUT_BLOCK: Any

class KindId(enum.IntEnum):
    AMBIGUOUS: int
    KEYWORD: int
    TYPE: int
    FUNCTION: int
    NAMESPACE: int
    NAVIGATION: int
    MARKUP: int
    VARIABLE: int
    SNIPPET: int
    COLOR_REDISH: int
    COLOR_ORANGISH: int
    COLOR_YELLOWISH: int
    COLOR_GREENISH: int
    COLOR_CYANISH: int
    COLOR_BLUISH: int
    COLOR_PURPLISH: int
    COLOR_PINKISH: int
    COLOR_DARK: int
    COLOR_LIGHT: int

KIND_ID_AMBIGUOUS: Any
KIND_ID_KEYWORD: Any
KIND_ID_TYPE: Any
KIND_ID_FUNCTION: Any
KIND_ID_NAMESPACE: Any
KIND_ID_NAVIGATION: Any
KIND_ID_MARKUP: Any
KIND_ID_VARIABLE: Any
KIND_ID_SNIPPET: Any
KIND_ID_COLOR_REDISH: Any
KIND_ID_COLOR_ORANGISH: Any
KIND_ID_COLOR_YELLOWISH: Any
KIND_ID_COLOR_GREENISH: Any
KIND_ID_COLOR_CYANISH: Any
KIND_ID_COLOR_BLUISH: Any
KIND_ID_COLOR_PURPLISH: Any
KIND_ID_COLOR_PINKISH: Any
KIND_ID_COLOR_DARK: Any
KIND_ID_COLOR_LIGHT: Any
KIND_AMBIGUOUS: Any
KIND_KEYWORD: Any
KIND_TYPE: Any
KIND_FUNCTION: Any
KIND_NAMESPACE: Any
KIND_NAVIGATION: Any
KIND_MARKUP: Any
KIND_VARIABLE: Any
KIND_SNIPPET: Any

class SymbolSource(enum.IntEnum):
    ANY: int
    INDEX: int
    OPEN_FILES: int

SYMBOL_SOURCE_ANY: Any
SYMBOL_SOURCE_INDEX: Any
SYMBOL_SOURCE_OPEN_FILES: Any

class SymbolType(enum.IntEnum):
    ANY: int
    DEFINITION: int
    REFERENCE: int

SYMBOL_TYPE_ANY: Any
SYMBOL_TYPE_DEFINITION: Any
SYMBOL_TYPE_REFERENCE: Any

class CompletionFormat(enum.IntEnum):
    TEXT: int
    SNIPPET: int
    COMMAND: int

COMPLETION_FORMAT_TEXT: Any
COMPLETION_FORMAT_SNIPPET: Any
COMPLETION_FORMAT_COMMAND: Any

def version() -> str: ...
def platform() -> Literal['osx', 'linux', 'windows']: ...
def arch() -> Literal['x32', 'x64', 'arm64']: ...
def channel() -> Literal['dev', 'stable']: ...
def executable_path() -> str: ...
def executable_hash() -> tuple[str, str, str]: ...
def packages_path() -> str: ...
def installed_packages_path() -> str: ...
def cache_path() -> str: ...
def status_message(msg: str): ...
def error_message(msg: str): ...
def message_dialog(msg: str): ...
def ok_cancel_dialog(msg: str, ok_title: str = ..., title: str = ...) -> bool: ...
def yes_no_cancel_dialog(msg: str, yes_title: str = ..., no_title: str = ..., title: str = ...) -> DialogResult: ...
def open_dialog(callback: Callable[[Union[str, list[str], None]], None], file_types: list[tuple[str, list[str]]] = ..., directory: Optional[str] = ..., multi_select: bool = ..., allow_folders: bool = ...): ...
def save_dialog(callback: Callable[[Union[str, None]], None], file_types: list[tuple[str, list[str]]] = ..., directory: Optional[str] = ..., name: Optional[str] = ..., extension: Optional[str] = ...): ...
def select_folder_dialog(callback: Callable[[Union[str, list[str], None]], None], directory: Optional[str] = ..., multi_select: bool = ...): ...
def choose_font_dialog(callback: Callable[[Value], None], default: dict[str, Value] = ...): ...
def run_command(cmd: str, args: CommandArgs = ...): ...
def format_command(cmd: str, args: CommandArgs = ...) -> str: ...
def html_format_command(cmd: str, args: CommandArgs = ...) -> str: ...
def command_url(cmd: str, args: CommandArgs = ...) -> str: ...
def get_clipboard_async(callback: Callable[[str], None], size_limit: int = ...): ...
def get_clipboard(size_limit: int = ...) -> str: ...
def set_clipboard(text: str): ...
def log_commands(flag: Optional[bool] = ...): ...
def get_log_commands() -> bool: ...
def log_input(flag: Optional[bool] = ...): ...
def get_log_input() -> bool: ...
def log_fps(flag: Optional[bool] = ...): ...
def get_log_fps() -> bool: ...
def log_result_regex(flag: Optional[bool] = ...): ...
def get_log_result_regex() -> bool: ...
def log_indexing(flag: Optional[bool] = ...): ...
def get_log_indexing() -> bool: ...
def log_build_systems(flag: Optional[bool] = ...): ...
def get_log_build_systems() -> bool: ...
def log_control_tree(flag: Optional[bool] = ...): ...
def get_log_control_tree() -> bool: ...
def ui_info() -> dict: ...
def score_selector(scope_name: str, selector: str) -> int: ...
def load_resource(name: str) -> str: ...
def load_binary_resource(name) -> bytes: ...
def find_resources(pattern: str) -> list[str]: ...
def encode_value(value: Value, pretty: bool = ..., update_text: str = ...) -> str: ...
def decode_value(data: str) -> Value: ...
def expand_variables(value: Value, variables: dict[str, str]) -> Value: ...
def load_settings(base_name: str) -> Settings: ...
def save_settings(base_name: str): ...
def set_timeout(callback: Callable, delay: int = ...): ...
def set_timeout_async(callback: Callable, delay: int = ...): ...
def active_window() -> Window: ...
def windows() -> list[Window]: ...
def get_macro() -> list[dict]: ...
def project_history() -> list[str]: ...
def folder_history() -> list[str]: ...

class Window:
    window_id: Any
    settings_object: Any
    template_settings_object: Any
    def __init__(self, id: int) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other): ...
    def __bool__(self) -> bool: ...
    def id(self) -> int: ...
    def is_valid(self) -> bool: ...
    def hwnd(self) -> int: ...
    def active_sheet(self) -> Optional[Sheet]: ...
    def active_view(self) -> Optional[View]: ...
    def new_html_sheet(self, name: str, contents: str, flags=..., group: int = ...) -> Sheet: ...
    def run_command(self, cmd: str, args: CommandArgs = ...): ...
    def new_file(self, flags=..., syntax: str = ...) -> View: ...
    def open_file(self, fname: str, flags=..., group: int = ...) -> View: ...
    def find_open_file(self, fname: str, group: int = ...) -> Optional[View]: ...
    def file_history(self) -> list[str]: ...
    def num_groups(self) -> int: ...
    def active_group(self) -> int: ...
    def focus_group(self, idx: int): ...
    def focus_sheet(self, sheet: Sheet): ...
    def focus_view(self, view: View): ...
    def select_sheets(self, sheets: list[Sheet]): ...
    def bring_to_front(self) -> None: ...
    def get_sheet_index(self, sheet: Sheet) -> tuple[int, int]: ...
    def get_view_index(self, view: View) -> tuple[int, int]: ...
    def set_sheet_index(self, sheet: Sheet, group: int, index: int): ...
    def set_view_index(self, view: View, group: int, index: int): ...
    def move_sheets_to_group(self, sheets: list[Sheet], group: int, insertion_idx: int = ..., select: bool = ...): ...
    def sheets(self) -> list[Sheet]: ...
    def views(self, *, include_transient: bool = ...) -> list[View]: ...
    def selected_sheets(self) -> list[Sheet]: ...
    def selected_sheets_in_group(self, group: int) -> list[Sheet]: ...
    def active_sheet_in_group(self, group: int) -> Optional[Sheet]: ...
    def active_view_in_group(self, group: int) -> Optional[View]: ...
    def sheets_in_group(self, group: int) -> list[Sheet]: ...
    def views_in_group(self, group: int) -> list[View]: ...
    def num_sheets_in_group(self, group: int) -> int: ...
    def num_views_in_group(self, group: int) -> int: ...
    def transient_sheet_in_group(self, group: int) -> Optional[Sheet]: ...
    def transient_view_in_group(self, group: int) -> Optional[View]: ...
    def promote_sheet(self, sheet: Sheet): ...
    def layout(self) -> dict[str, Value]: ...
    def get_layout(self): ...
    def set_layout(self, layout: dict[str, Value]): ...
    def create_output_panel(self, name: str, unlisted: bool = ...) -> View: ...
    def find_output_panel(self, name: str) -> Optional[View]: ...
    def destroy_output_panel(self, name: str): ...
    def active_panel(self) -> Optional[str]: ...
    def panels(self) -> list[str]: ...
    def get_output_panel(self, name: str): ...
    def show_input_panel(self, caption: str, initial_text: str, on_done: Optional[Callable[[str], None]], on_change: Optional[Callable[[str], None]], on_cancel: Optional[Callable[[], None]]): ...
    def show_quick_panel(self, items: Union[list[str], list[list[str]], list[QuickPanelItem]], on_select: Callable[[int], None], flags=..., selected_index: int = ..., on_highlight: Optional[Callable[[int], None]] = ..., placeholder: Optional[str] = ...): ...
    def is_sidebar_visible(self) -> bool: ...
    def set_sidebar_visible(self, flag: bool, animate: bool = ...): ...
    def is_minimap_visible(self) -> bool: ...
    def set_minimap_visible(self, flag: bool): ...
    def is_status_bar_visible(self) -> bool: ...
    def set_status_bar_visible(self, flag: bool): ...
    def get_tabs_visible(self) -> bool: ...
    def set_tabs_visible(self, flag: bool): ...
    def is_menu_visible(self) -> bool: ...
    def set_menu_visible(self, flag: bool): ...
    def folders(self) -> list[str]: ...
    def project_file_name(self) -> Optional[str]: ...
    def workspace_file_name(self) -> Optional[str]: ...
    def project_data(self) -> Value: ...
    def set_project_data(self, data: Value): ...
    def settings(self) -> Settings: ...
    def template_settings(self) -> Settings: ...
    def symbol_locations(self, sym: str, source=..., type=..., kind_id=..., kind_letter: str = ...) -> list[SymbolLocation]: ...
    def lookup_symbol_in_index(self, symbol: str) -> list[SymbolLocation]: ...
    def lookup_symbol_in_open_files(self, symbol: str) -> list[SymbolLocation]: ...
    def lookup_references_in_index(self, symbol: str) -> list[SymbolLocation]: ...
    def lookup_references_in_open_files(self, symbol: str) -> list[SymbolLocation]: ...
    def extract_variables(self) -> dict[str, str]: ...
    def status_message(self, msg: str): ...

class Edit:
    edit_token: Any
    def __init__(self, token: int) -> None: ...

class Region:
    a: Any
    b: Any
    xpos: Any
    def __init__(self, a: Point, b: Optional[Point] = ..., xpos: DIP = ...) -> None: ...
    def __iter__(self): ...
    def __len__(self) -> int: ...
    def __eq__(self, rhs: object) -> bool: ...
    def __lt__(self, rhs: Region) -> bool: ...
    def __contains__(self, v: Union[Region, Point]) -> bool: ...
    def to_tuple(self) -> tuple[Point, Point]: ...
    def empty(self) -> bool: ...
    def begin(self) -> Point: ...
    def end(self) -> Point: ...
    def size(self) -> int: ...
    def contains(self, x: Point) -> bool: ...
    def cover(self, region: Region) -> Region: ...
    def intersection(self, region: Region) -> Region: ...
    def intersects(self, region: Region) -> bool: ...

class HistoricPosition:
    pt: Any
    row: Any
    col: Any
    col_utf16: Any
    col_utf8: Any
    def __init__(self, pt: Point, row: int, col: int, col_utf16: int, col_utf8: int) -> None: ...

class TextChange:
    a: Any
    b: Any
    len_utf16: Any
    len_utf8: Any
    str: Any
    def __init__(self, pa: HistoricPosition, pb: HistoricPosition, len_utf16: int, len_utf8: int, s: str) -> None: ...

class Selection:
    view_id: Any
    def __init__(self, id) -> None: ...
    def __iter__(self) -> Iterator[Region]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int) -> Region: ...
    def __delitem__(self, index: int): ...
    def __eq__(self, rhs: object) -> bool: ...
    def __lt__(self, rhs: Optional[Selection]) -> bool: ...
    def __bool__(self) -> bool: ...
    def is_valid(self) -> bool: ...
    def clear(self) -> None: ...
    def add(self, x: Union[Region, Point]): ...
    def add_all(self, regions: Iterable[Union[Region, Point]]): ...
    def subtract(self, region: Region): ...
    def contains(self, region: Region) -> bool: ...

def make_sheet(sheet_id): ...

class Sheet:
    sheet_id: Any
    def __init__(self, id) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def id(self) -> int: ...
    def window(self) -> Optional[Window]: ...
    def view(self) -> Optional[View]: ...
    def file_name(self) -> Optional[str]: ...
    def is_semi_transient(self) -> bool: ...
    def is_transient(self) -> bool: ...
    def is_selected(self) -> bool: ...
    def group(self) -> Optional[int]: ...
    def close(self, on_close=...) -> None: ...

class TextSheet(Sheet):
    def set_name(self, name: str): ...

class ImageSheet(Sheet): ...

class HtmlSheet(Sheet):
    def set_name(self, name: str): ...
    def set_contents(self, contents: str): ...

class ContextStackFrame:
    context_name: Any
    source_file: Any
    source_location: Any
    def __init__(self, context_name: str, source_file: str, source_location: tuple[int, int]) -> None: ...

class View:
    view_id: Any
    selection: Any
    settings_object: Any
    def __init__(self, id) -> None: ...
    def __len__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __bool__(self) -> bool: ...
    def id(self) -> int: ...
    def buffer_id(self) -> int: ...
    def buffer(self) -> Buffer: ...
    def sheet_id(self) -> int: ...
    def sheet(self) -> Optional[Sheet]: ...
    def element(self) -> Optional[str]: ...
    def is_valid(self) -> bool: ...
    def is_primary(self) -> bool: ...
    def window(self) -> Optional[Window]: ...
    def clones(self) -> list[View]: ...
    def file_name(self) -> Optional[str]: ...
    def close(self, on_close=...) -> bool: ...
    def retarget(self, new_fname: str): ...
    def name(self) -> str: ...
    def set_name(self, name: str): ...
    def reset_reference_document(self) -> None: ...
    def set_reference_document(self, reference: str): ...
    def is_loading(self) -> bool: ...
    def is_dirty(self) -> bool: ...
    def is_read_only(self) -> bool: ...
    def set_read_only(self, read_only: bool): ...
    def is_scratch(self) -> bool: ...
    def set_scratch(self, scratch: bool): ...
    def encoding(self) -> str: ...
    def set_encoding(self, encoding_name: str): ...
    def line_endings(self) -> str: ...
    def set_line_endings(self, line_ending_name: str): ...
    def size(self) -> int: ...
    def begin_edit(self, edit_token: int, cmd: str, args: CommandArgs = ...) -> Edit: ...
    def end_edit(self, edit: Edit): ...
    def is_in_edit(self) -> bool: ...
    def insert(self, edit: Edit, pt: Point, text: str) -> int: ...
    def erase(self, edit: Edit, region: Region): ...
    def replace(self, edit: Edit, region: Region, text: str): ...
    def change_count(self) -> int: ...
    def change_id(self) -> tuple[int, int, int]: ...
    def transform_region_from(self, region: Region, change_id: tuple[int, int, int]) -> Region: ...
    def run_command(self, cmd: str, args: CommandArgs = ...): ...
    def sel(self) -> Selection: ...
    def substr(self, x: Union[Region, Point]) -> str: ...
    def find(self, pattern: str, start_pt: Point, flags=...) -> Region: ...
    def find_all(self, pattern: str, flags=..., fmt: Optional[str] = ..., extractions: Optional[list[str]] = ...) -> list[Region]: ...
    def settings(self) -> Settings: ...
    def meta_info(self, key: str, pt: Point) -> Value: ...
    def extract_tokens_with_scopes(self, region: Region) -> list[tuple[Region, str]]: ...
    def extract_scope(self, pt: Point) -> Region: ...
    def expand_to_scope(self, pt: Point, selector: str) -> Optional[Region]: ...
    def scope_name(self, pt: Point) -> str: ...
    def context_backtrace(self, pt: Point) -> list[ContextStackFrame]: ...
    def match_selector(self, pt: Point, selector: str) -> bool: ...
    def score_selector(self, pt: Point, selector: str) -> int: ...
    def find_by_selector(self, selector: str) -> list[Region]: ...
    def style(self) -> dict[str, str]: ...
    def style_for_scope(self, scope: str) -> dict[str, Value]: ...
    def indented_region(self, pt: Point) -> Region: ...
    def indentation_level(self, pt: Point) -> int: ...
    def has_non_empty_selection_region(self) -> bool: ...
    def lines(self, region: Region) -> list[Region]: ...
    def split_by_newlines(self, region: Region) -> list[Region]: ...
    def line(self, x: Union[Region, Point]) -> Region: ...
    def full_line(self, x: Union[Region, Point]) -> Region: ...
    def word(self, x: Union[Region, Point]) -> Region: ...
    def classify(self, pt: Point) -> PointClassification: ...
    def find_by_class(self, pt: Point, forward: bool, classes: PointClassification, separators: str = ..., sub_word_separators: str = ...) -> Point: ...
    def expand_by_class(self, x: Union[Region, Point], classes: PointClassification, separators: str = ..., sub_word_separators: str = ...) -> Region: ...
    def rowcol(self, tp: Point) -> tuple[int, int]: ...
    def rowcol_utf8(self, tp: Point) -> tuple[int, int]: ...
    def rowcol_utf16(self, tp: Point) -> tuple[int, int]: ...
    def text_point(self, row: int, col: int, *, clamp_column: bool = ...) -> Point: ...
    def text_point_utf8(self, row: int, col: int, *, clamp_column: bool = ...) -> Point: ...
    def text_point_utf16(self, row: int, col: int, *, clamp_column: bool = ...) -> Point: ...
    def utf8_code_units(self, tp: Point = ...) -> int: ...
    def utf16_code_units(self, tp: Point = ...) -> int: ...
    def visible_region(self) -> Region: ...
    def show(self, location: Union[Region, Selection, Point], show_surrounds: bool = ..., keep_to_left: bool = ..., animate: bool = ...): ...
    def show_at_center(self, location: Union[Region, Point], animate: bool = ...): ...
    def viewport_position(self) -> Vector: ...
    def set_viewport_position(self, xy: Vector, animate: bool = ...): ...
    def viewport_extent(self) -> Vector: ...
    def layout_extent(self) -> Vector: ...
    def text_to_layout(self, tp: Point) -> Vector: ...
    def text_to_window(self, tp: Point) -> Vector: ...
    def layout_to_text(self, xy: Vector) -> Point: ...
    def layout_to_window(self, xy: Vector) -> Vector: ...
    def window_to_layout(self, xy: Vector) -> Vector: ...
    def window_to_text(self, xy: Vector) -> Point: ...
    def line_height(self) -> DIP: ...
    def em_width(self) -> DIP: ...
    def is_folded(self, region: Region) -> bool: ...
    def folded_regions(self) -> list[Region]: ...
    def fold(self, x: Union[Region, list[Region]]) -> bool: ...
    def unfold(self, x: Union[Region, list[Region]]) -> list[Region]: ...
    def add_regions(self, key: str, regions: list[Region], scope: str = ..., icon: str = ..., flags=..., annotations: list[str] = ..., annotation_color: str = ..., on_navigate: Optional[Callable[[str], None]] = ..., on_close: Optional[Callable[[], None]] = ...): ...
    def get_regions(self, key: str) -> list[Region]: ...
    def erase_regions(self, key: str): ...
    def add_phantom(self, key: str, region: Region, content: str, layout: PhantomLayout, on_navigate: Optional[Callable[[str], None]] = ...) -> int: ...
    def erase_phantoms(self, key: str): ...
    def erase_phantom_by_id(self, pid: int): ...
    def query_phantom(self, pid: int) -> list[Region]: ...
    def query_phantoms(self, pids: list[int]) -> list[Region]: ...
    def assign_syntax(self, syntax: Union[str, Syntax]): ...
    def set_syntax_file(self, syntax_file: str): ...
    def syntax(self) -> Optional[Syntax]: ...
    def symbols(self) -> list[tuple[Region, str]]: ...
    def get_symbols(self) -> list[tuple[Region, str]]: ...
    def indexed_symbols(self) -> list[tuple[Region, str]]: ...
    def indexed_references(self) -> list[tuple[Region, str]]: ...
    def symbol_regions(self) -> list[SymbolRegion]: ...
    def indexed_symbol_regions(self, type=...) -> list[SymbolRegion]: ...
    def set_status(self, key: str, value: str): ...
    def get_status(self, key: str) -> str: ...
    def erase_status(self, key: str): ...
    def extract_completions(self, prefix: str, tp: Point = ...) -> list[str]: ...
    def find_all_results(self) -> list[tuple[str, int, int]]: ...
    def find_all_results_with_text(self) -> list[tuple[str, int, int, str]]: ...
    def command_history(self, index: int, modifying_only: bool = ...) -> tuple[str, CommandArgs, int]: ...
    def overwrite_status(self) -> bool: ...
    def set_overwrite_status(self, value: bool): ...
    def show_popup_menu(self, items: list[str], on_done: Callable[[int], None], flags: int = ...): ...
    def show_popup(self, content: str, flags=..., location: Point = ..., max_width: DIP = ..., max_height: DIP = ..., on_navigate: Optional[Callable[[str], None]] = ..., on_hide: Optional[Callable[[], None]] = ...): ...
    def update_popup(self, content: str): ...
    def is_popup_visible(self) -> bool: ...
    def hide_popup(self) -> None: ...
    def is_auto_complete_visible(self) -> bool: ...
    def preserve_auto_complete_on_focus_lost(self) -> None: ...
    def export_to_html(self, regions: Optional[Union[Region, list[Region]]] = ..., minihtml: bool = ..., enclosing_tags: bool = ..., font_size: bool = ..., font_family: bool = ...): ...
    def clear_undo_stack(self) -> None: ...

class Buffer:
    buffer_id: Any
    def __init__(self, id) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def id(self) -> int: ...
    def file_name(self) -> Optional[str]: ...
    def views(self) -> list[View]: ...
    def primary_view(self) -> View: ...

class Settings:
    settings_id: Any
    def __init__(self, id) -> None: ...
    def __getitem__(self, key: str) -> Value: ...
    def __setitem__(self, key: str, value: Value): ...
    def __delitem__(self, key: str): ...
    def __contains__(self, key: str) -> bool: ...
    def to_dict(self) -> dict: ...
    def setdefault(self, key: str, value: Value): ...
    def update(self, other=..., **kwargs) -> None: ...
    def get(self, key: str, default: Value = ...) -> Value: ...
    def has(self, key: str) -> bool: ...
    def set(self, key: str, value: Value): ...
    def erase(self, key: str): ...
    def add_on_change(self, tag: str, callback: Callable[[], None]): ...
    def clear_on_change(self, tag: str): ...

class Phantom:
    region: Any
    content: Any
    layout: Any
    on_navigate: Any
    id: Any
    def __init__(self, region: Region, content: str, layout: PhantomLayout, on_navigate: Callable[[str], None] = ...) -> None: ...
    def __eq__(self, rhs: object) -> bool: ...
    def to_tuple(self) -> tuple[tuple[Point, Point], str, PhantomLayout, Optional[Callable[[str], None]]]: ...

class PhantomSet:
    view: Any
    key: Any
    phantoms: Any
    def __init__(self, view: View, key: str = ...) -> None: ...
    def __del__(self) -> None: ...
    def update(self, phantoms: Iterable[Phantom]): ...

class Html:
    data: Any
    def __init__(self, data: str) -> None: ...

class CompletionList:
    target: Any
    completions: Any
    flags: Any
    def __init__(self, completions: Optional[list[CompletionValue]] = ..., flags=...) -> None: ...
    def set_completions(self, completions: list[CompletionValue], flags=...): ...

class CompletionItem:
    trigger: Any
    annotation: Any
    completion: Any
    completion_format: Any
    kind: Any
    details: Any
    flags: Any
    def __init__(self, trigger: str, annotation: str = ..., completion: str = ..., completion_format=..., kind=..., details: str = ..., flags=...) -> None: ...
    def __eq__(self, rhs: object) -> bool: ...
    @classmethod
    def snippet_completion(cls, trigger: str, snippet: str, annotation: str = ..., kind=..., details: str = ...) -> CompletionItem: ...
    @classmethod
    def command_completion(cls, trigger: str, command: str, args: CommandArgs = ..., annotation: str = ..., kind=..., details: str = ...) -> CompletionItem: ...

def list_syntaxes() -> list[Syntax]: ...
def syntax_from_path(path: str) -> Optional[Syntax]: ...
def find_syntax_by_name(name: str) -> list[Syntax]: ...
def find_syntax_by_scope(scope: str) -> list[Syntax]: ...
def find_syntax_for_file(path, first_line: str = ...) -> Optional[Syntax]: ...

class Syntax:
    path: Any
    name: Any
    hidden: Any
    scope: Any
    def __init__(self, path: str, name: str, hidden: bool, scope: str) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

class QuickPanelItem:
    trigger: Any
    details: Any
    annotation: Any
    kind: Any
    def __init__(self, trigger: str, details: str = ..., annotation: str = ..., kind=...) -> None: ...

class ListInputItem:
    text: Any
    value: Any
    details: Any
    annotation: Any
    kind: Any
    def __init__(self, text: str, value: Any, details: str = ..., annotation: str = ..., kind=...) -> None: ...

class SymbolRegion:
    name: Any
    region: Any
    syntax: Any
    type: Any
    kind: Any
    def __init__(self, name: str, region: Region, syntax: str, type: SymbolType, kind: Kind) -> None: ...

class SymbolLocation:
    path: Any
    display_name: Any
    row: Any
    col: Any
    syntax: Any
    type: Any
    kind: Any
    def __init__(self, path: str, display_name: str, row: int, col: int, syntax: str, type: SymbolType, kind: Kind) -> None: ...
    def path_encoded_position(self) -> str: ...
