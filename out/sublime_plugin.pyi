import importlib
import sublime
from _typeshed import Incomplete
from collections.abc import Generator
from sublime_types import CommandArgs as CommandArgs, CompletionValue as CompletionValue, DIP as DIP, Event as Event, Kind as Kind, Point as Point, Value as Value, Vector as Vector
from typing import Optional

api_ready: bool
deferred_plugin_loadeds: Incomplete
application_command_classes: Incomplete
window_command_classes: Incomplete
text_command_classes: Incomplete
view_event_listener_classes: Incomplete
view_event_listeners: Incomplete
all_command_classes: Incomplete
all_callbacks: Incomplete
pending_on_activated_async_lock: Incomplete
pending_on_activated_async_callbacks: Incomplete
view_event_listener_excluded_callbacks: Incomplete
text_change_listener_classes: Incomplete
text_change_listener_callbacks: Incomplete
text_change_listeners: Incomplete
profile: Incomplete

def add_profiling(event_handler): ...
def trap_exceptions(event_handler): ...
def decorate_handler(cls, method_name) -> None: ...
def unload_module(module) -> None: ...
def unload_plugin(modulename) -> None: ...
def reload_plugin(modulename) -> None: ...
def load_module(m) -> None: ...
def synthesize_on_activated_async() -> None: ...
def notify_application_commands() -> None: ...
def create_application_commands(): ...
def create_window_commands(window_id): ...
def create_text_commands(view_id): ...
def on_api_ready() -> None: ...
def is_view_event_listener_applicable(cls, view): ...
def create_view_event_listeners(classes, view) -> None: ...
def check_view_event_listeners(view) -> None: ...
def attach_view(view): ...

check_all_view_event_listeners_scheduled: bool

def check_all_view_event_listeners() -> None: ...
def detach_view(view) -> None: ...
def find_view_event_listener(view, cls): ...
def attach_buffer(buf) -> None: ...
def check_text_change_listeners(buf) -> None: ...
def detach_buffer(buf) -> None: ...
def plugin_module_for_obj(obj): ...
def el_callbacks(name, listener_only: bool = ...) -> Generator[Incomplete, None, None]: ...
def vel_callbacks(v, name, listener_only: bool = ...) -> Generator[Incomplete, None, None]: ...
def run_view_callbacks(name, view_id, *args, el_only: bool = ...) -> None: ...
def run_window_callbacks(name, window_id, *args) -> None: ...
def on_init(module) -> None: ...
def on_new(view_id) -> None: ...
def on_new_async(view_id) -> None: ...
def on_new_buffer(buffer_id) -> None: ...
def on_new_buffer_async(buffer_id) -> None: ...
def on_associate_buffer(buffer_id) -> None: ...
def on_associate_buffer_async(buffer_id) -> None: ...
def on_close_buffer(buffer_id) -> None: ...
def on_close_buffer_async(buffer_id) -> None: ...
def on_clone(view_id) -> None: ...
def on_clone_async(view_id) -> None: ...

class Summary:
    max: float
    sum: float
    count: int
    def __init__(self) -> None: ...
    def record(self, x) -> None: ...

def get_profiling_data(): ...
def on_load(view_id) -> None: ...
def on_load_async(view_id) -> None: ...
def on_revert(view_id) -> None: ...
def on_revert_async(view_id) -> None: ...
def on_reload(view_id) -> None: ...
def on_reload_async(view_id) -> None: ...
def on_pre_close(view_id) -> None: ...
def on_close(view_id) -> None: ...
def on_pre_save(view_id) -> None: ...
def on_pre_save_async(view_id) -> None: ...
def on_post_save(view_id) -> None: ...
def on_post_save_async(view_id) -> None: ...
def on_pre_move(view_id) -> None: ...
def on_post_move(view_id) -> None: ...
def on_post_move_async(view_id) -> None: ...
def on_modified(view_id) -> None: ...
def on_modified_async(view_id) -> None: ...
def on_selection_modified(view_id) -> None: ...
def on_selection_modified_async(view_id) -> None: ...
def on_activated(view_id) -> None: ...
def on_activated_async(view_id) -> None: ...
def on_deactivated(view_id) -> None: ...
def on_deactivated_async(view_id) -> None: ...
def on_query_context(view_id, key, operator, operand, match_all): ...
def normalise_completion(c): ...

class MultiCompletionList:
    remaining_calls: Incomplete
    view_id: Incomplete
    req_id: Incomplete
    completions: Incomplete
    flags: int
    def __init__(self, num_completion_lists, view_id, req_id) -> None: ...
    def completions_ready(self, completions, flags) -> None: ...

def on_query_completions(view_id, req_id, prefix, locations) -> None: ...
def on_hover(view_id, point, hover_zone) -> None: ...
def on_text_command(view_id, name, args): ...
def on_window_command(window_id, name, args): ...
def on_post_text_command(view_id, name, args) -> None: ...
def on_post_window_command(window_id, name, args) -> None: ...
def on_new_project(window_id) -> None: ...
def on_new_project_async(window_id) -> None: ...
def on_load_project(window_id) -> None: ...
def on_load_project_async(window_id) -> None: ...
def on_pre_save_project(window_id) -> None: ...
def on_post_save_project(window_id) -> None: ...
def on_post_save_project_async(window_id) -> None: ...
def on_pre_close_project(window_id) -> None: ...
def on_new_window(window_id) -> None: ...
def on_new_window_async(window_id) -> None: ...
def on_pre_close_window(window_id) -> None: ...
def on_exit(log_path) -> None: ...

class CommandInputHandler:
    def name(self) -> str: ...
    def placeholder(self) -> str: ...
    def initial_text(self) -> str: ...
    def initial_selection(self) -> list[tuple[int, int]]: ...
    def preview(self, text: str) -> Union[str, sublime.Html]: ...
    def validate(self, text: str) -> bool: ...
    def cancel(self) -> None: ...
    def confirm(self, text: str): ...
    def next_input(self, args) -> Optional[CommandInputHandler]: ...
    def create_input_handler_(self, args): ...
    def preview_(self, v): ...
    def validate_(self, v, event): ...
    def cancel_(self) -> None: ...
    def confirm_(self, v, event) -> None: ...
    def want_event(self) -> bool: ...

class BackInputHandler(CommandInputHandler):
    def name(self): ...

class TextInputHandler(CommandInputHandler):
    def description(self, text: str) -> str: ...
    def setup_(self, args): ...
    def description_(self, v, text): ...

class ListInputHandler(CommandInputHandler):
    def list_items(self) -> Union[list[str], tuple[list[str], int], list[tuple[str, Value]], tuple[list[tuple[str, Value]], int], list[sublime.ListInputItem], tuple[list[sublime.ListInputItem], int]]: ...
    def description(self, value, text: str) -> str: ...
    def setup_(self, args): ...
    def description_(self, v, text): ...

class Command:
    def name(self) -> str: ...
    def is_enabled_(self, args): ...
    def is_enabled(self) -> bool: ...
    def is_visible_(self, args): ...
    def is_visible(self) -> bool: ...
    def is_checked_(self, args): ...
    def is_checked(self) -> bool: ...
    def description_(self, args): ...
    def description(self) -> Optional[str]: ...
    def filter_args(self, args): ...
    def want_event(self) -> bool: ...
    def input(self, args: dict) -> Optional[CommandInputHandler]: ...
    def input_description(self) -> str: ...
    def create_input_handler_(self, args): ...
    def run(self) -> None: ...

class ApplicationCommand(Command):
    def run_(self, edit_token, args): ...
    def run(self) -> None: ...

class WindowCommand(Command):
    window: Incomplete
    def __init__(self, window) -> None: ...
    def run_(self, edit_token, args): ...
    def run(self) -> None: ...

class TextCommand(Command):
    view: Incomplete
    def __init__(self, view) -> None: ...
    def run_(self, edit_token, args): ...
    def run(self, edit: sublime.Edit): ...

class EventListener: ...

class ViewEventListener:
    @classmethod
    def is_applicable(cls, settings: sublime.Settings) -> bool: ...
    @classmethod
    def applies_to_primary_view_only(cls) -> bool: ...
    view: Incomplete
    def __init__(self, view: sublime.View) -> None: ...

class TextChangeListener:
    @classmethod
    def is_applicable(cls, buffer: sublime.Buffer): ...
    buffer: Incomplete
    def __init__(self) -> None: ...
    def detach(self) -> None: ...
    def attach(self, buffer: sublime.Buffer): ...
    def is_attached(self) -> bool: ...

class MultizipImporter(importlib.abc.MetaPathFinder):
    loaders: Incomplete
    def __init__(self) -> None: ...
    def find_spec(self, fullname, path, target: Incomplete | None = ...): ...

class ZipResourceReader(importlib.abc.ResourceReader):
    loader: Incomplete
    fullname: Incomplete
    def __init__(self, loader, fullname) -> None: ...
    def open_resource(self, resource): ...
    def resource_path(self, resource) -> None: ...
    def is_resource(self, name): ...
    def contents(self): ...

class ZipLoader(importlib.abc.InspectLoader):
    zippath: Incomplete
    name: Incomplete
    def __init__(self, zippath) -> None: ...
    def has(self, fullname): ...
    def get_resource_reader(self, fullname): ...
    def get_filename(self, fullname): ...
    def get_code(self, fullname): ...
    def get_source(self, fullname): ...
    def is_package(self, fullname): ...

override_path: Incomplete
multi_importer: Incomplete

def update_compressed_packages(pkgs) -> None: ...
def set_override_path(path) -> None: ...
